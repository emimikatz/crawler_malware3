"""
controller.py
"""
import os
import time
import subprocess
import requests
import gridfs
from celery import Celery
from pymongo import MongoClient
import app.exceptions as exc

from app.view import view
from app.model import model_malware
from app.model import model_ip
from app.model import model_label
from app.model import model_vt
from app.model import model_gridfs
from app.controller import utils
from werkzeug.utils import secure_filename

import configuration_file as cfg

class Controller():

    """
    Class Controller
    """

    def __init__(self):
        """
        Initialisation of the controller class
        Params:
        - self
        Returns:
        - none
        """

        self._view = view.View()

        self._client = MongoClient(cfg.mongo_config["client"])
        dbnames = self._client.list_database_names()
        
        self._db = self._client.crawler_malware
        self._model_malware = model_malware.ModelMalware(self._db)
        self._model_ip = model_ip.ModelIP(self._db)
        self._model_vt = model_vt.ModelVT(self._db)
        self._model_label = model_label.ModelLabel(self._db)
        self._model_gridfs = model_gridfs.ModelGridFS(self._db)
        
        
        if cfg.mongo_config["db_name"] not in dbnames:
            self.initialisation()

    def initialisation(self):
        """
        Erase and recreate the collections and erase the grifs database
        Params:
        - self
        Returns:
        - none
        """
        self._create_collections()
        self._erase_gridfs()

    @property
    def _connection(self):
        """
        Connection to the database
        Params:
        - self
        Returns:
        - the database db
        """
        return self._db

    def _erase_gridfs(self):
        """
        Erase gridfs database
        Params:
        - none
        Returns:
        - none
        """
        fs_db = gridfs.GridFSBucket(self._db)
        for gridout in fs_db.find():
            fs_db.delete(gridout._id)

    def _create_collections(self):
        """
        Create collection
        Params:
        - db
        Returns:
        - none
        """
        try:
            self._model_malware.create_malware_collection()
            self._model_vt.create_vt_collection()
            self._model_label.create_label_collection()
            self._model_ip.create_ip_collection()
        except exc.CreateCollectionError as create_collection_error:
            self._view.create_collection_error(create_collection_error)

    def parse_csv_urlhaus(self, request):
        """
        Parsing csv file from urlhaus
        Params:
        - request: (type: string).
        Returns:
        - name: (type: string).
        """
        try:
            lines = request.text.split('\n')

            reader = utils.break_csv(lines)
            for item in reader:
                if len(item) > 1:
                    id_malware, date_added, url_malware, url_status, threat, tags, urlhaus_link, reporter = utils.save_infos_from_csv(item)
                    self._insert_malware(
                        id_malware,
                        "urlhaus",
                        date_added,
                        url_malware,
                        url_status,
                        threat,
                        tags,
                        urlhaus_link,
                        reporter)
        except exc.ParseCSVError as parse_csv_error:
            self._view.parse_csv_error(parse_csv_error)

    def _insert_malware(self, id_malware, source_malware, date_added, url_malware, url_status, threat, tags, urlhaus_link, reporter_malware):
        try:
            if self._model_malware.select_one_malware_collection(str(id_malware)) is not None:
                raise exc.ItemAlreadyStored("ItemAlreadyStored exception")
            self._model_malware.add_malware_collection(id_malware, source_malware,
                                                       date_added, url_malware,
                                                       url_status, threat, tags,
                                                       urlhaus_link, reporter_malware)
            self._view.display_item_stored(id_malware, "malware")
            self._insert_ip(id_malware, url_malware)
            if url_status:
                id_file = self._model_gridfs.add_malware_file(url_malware, str(id_malware))
                if id_file is not None:
                    self._view.display_item_stored(id_malware, "file")
                    self._model_gridfs.file_from_db_to_hd(id_malware)
                    if utils.is_exe(tags):
                        self._model_malware.update_malware_imphash(id_malware, utils.get_imphash(id_malware))
                        self._view.display_item_updated(id_malware, "malware", "imphash")
                    self._model_malware.update_malware_md5_sha256_sha1_ssdeep(id_malware, utils.get_md5(id_malware),
                                                                              utils.get_sha256(id_malware), utils.get_sha1(id_malware),
                                                                              utils.get_ssdeep(id_malware))
                    self._view.display_item_updated(id_malware, "malware", "md5, sha256, sha1, ssdeep")

                    os.remove(cfg.malware["malware_path"] + id_malware)
        except (exc.InsertMalwareError, exc.ItemAlreadyStored) as insert_malware_error:
            self._view.display_insert_error(id_malware, "malware", insert_malware_error)

    def periodic_vt(self):
        """
        empty
        """
        while True:
            fs = gridfs.GridFSBucket(self._db)
            for gridout in fs.find():
                id_malware = gridout.filename
                malware = self._model_malware.select_one_malware_collection(id_malware)
                if malware["vt_report_malware"] is not True:
                    md5 = self._model_gridfs.get_file_from_gridfs(id_malware).md5
                    if self._get_virustotal(md5) is not None:
                        self._insert_vt(id_malware, md5)
                    else:
                        self._view.display_missing_item_error(id_malware, "vt")
                    time.sleep(25)

    def periodic_link(self):
        while True:
            collection = self._db['malware_collection']
            cursor = collection.find({})
            for document in cursor:
                if document['url_status_malware']:
                    try:
                        r = requests.get(document['url_malware'], stream=True, allow_redirects=True, timeout=10)
                    except:
                        self._model_malware.update_malware_urlstatus(document['id_malware'], False)
                        self._view.display_item_updated(document['id_malware'], "malware", "url_status")
                elif not document['url_status_malware']:
                    try:
                        r = requests.get(document['url_malware'], stream=True, allow_redirects=True, timeout=10)
                        self._model_malware.update_malware_urlstatus(document['id_malware'], True)
                        self._view.display_item_updated(document['id_malware'], "malware", "url_status")
                    except:
                        pass
                time.sleep(60)

    def _get_virustotal(self, md5):
        url_report = cfg.virustotal["url_report"]
        params_report = {'apikey': cfg.virustotal["apikey"], 'resource': md5}
        response_report = requests.get(url_report, params=params_report)
        if response_report.status_code == 200:
            response_json = response_report.json()
        elif response_report.status_code == 204:
            return
        if not response_json['verbose_msg'] == "Scan finished, scan information embedded in this object":
            url_scan = cfg.virustotal["url_scan"]
            params_scan = {'apikey': cfg.virustotal["apikey"]}
            #TODO
            return None
        else:
            md5 = response_json['md5']
            return response_json

    def _delete_malware(self, id_malware):
        """
        empty
        """
        try:
            self._model_malware.delete_one_malware_collection(id_malware)
            self._view.display_item_deletion(id_malware, "malware")
        except exc.ItemNotStored as exception_item_not_stored:
            self._view.display_item_not_yet_stored_error(id_malware, "malware", exception_item_not_stored)

    def _insert_ip(self, id_malware, url_malware):
        """
        empty
        """
        try:
            ip, country_name, country_code, continent_name, continent_code, region_name, region_code, city, zip, latitude, longitude, full_report = utils.get_ip_geo_from_url(url_malware)
            self._model_ip.add_ip_collection(id_malware, ip, country_name, country_code,
                                             continent_name, continent_code, region_name,
                                             region_code, city, zip, latitude, longitude,
                                             str(full_report))
            self._view.display_item_stored(id_malware, "ip")
        except exc.ItemAlreadyStored as exception_item_already_stored:
            self._view.display_insert_error(id_malware, "ip", exception_item_already_stored)

    def _delete_ip(self, id_malware_ip):
        """
        empty
        """
        try:
            self._model_ip.delete_one_ip_collection(id_malware_ip)
            self._view.display_item_deletion(id_malware_ip, "ip")
        except exc.ItemNotStored as exception_item_not_stored:
            self._view.display_item_not_yet_stored_error(id_malware_ip, "ip",
                                                         exception_item_not_stored)

    def _insert_label(self, id_malware_label):
        """
        Save the label avclass report.
        Params:
        - id+malware
        Returns:
        -
        """
        try:
            p = subprocess.Popen(['python3', 'avclass_labeler.py', '-vt', str(id_malware_label) + '.vt'], stdout=subprocess.PIPE)
            out, err = p.communicate()
            if str(out) == "b''":
                return
            elif "SINGLETON" in str(out):
                out = "singleton"
            else:
                out = str(out).split('\\')[1][1:]
            self._model_label.add_label_collection(str(id_malware_label), out)
            self._view.display_item_stored(id_malware_label, "label")
        except exc.ItemAlreadyStored as exception_item_already_stored:
            self._view.display_insert_error(id_malware_label, "label", exception_item_already_stored)

    def _delete_label(self, id_malware_label):
        """
        empty
        """
        try:
            self._model_label.delete_one_label_collection(id_malware_label)
            self._view.display_item_deletion(id_malware_label, "label")
        except exc.ItemNotStored as exception_item_not_stored:
            self._view.display_item_not_yet_stored_error(id_malware_label, "label", exception_item_not_stored)

    def _insert_vt(self, id_malware, md5):
        """
        empty
        """
        try:
            vt_report = self._get_virustotal(md5)
            if vt_report is not None:
                self._model_vt.add_vt_collection(vt_report['scan_id'],
                                                 vt_report['total'],
                                                 vt_report['positives'],
                                                 vt_report['resource'],
                                                 vt_report['response_code'],
                                                 vt_report['scan_date'],
                                                 vt_report['permalink'],
                                                 vt_report['sha256'],
                                                 vt_report['md5'],
                                                 vt_report['sha1'],
                                                 str(vt_report),
                                                 id_malware)
                self._view.display_item_stored(id_malware, "vt")
            self._model_malware.update_malware_vt(id_malware)
            os.chdir("avclassplusplus/")
            utils.save_vt_report(vt_report, id_malware)
            self._insert_label(id_malware)
            os.chdir("../")
            os.remove("avclassplusplus/" + secure_filename(id_malware) + ".vt")
        except exc.ItemAlreadyStored as exception_item_already_stored:
            self._view.display_insert_error(['scan_id'], "vt", exception_item_already_stored)


    def _delete_vt(self, scan_id_vt):
        """
        empty
        """
        try:
            self._model_vt.delete_one_vt_collection(scan_id_vt)
            self._view.display_item_deletion(scan_id_vt, "vt")
        except exc.ItemNotStored as exception_item_not_stored:
            self._view.display_item_not_yet_stored_error(scan_id_vt, "vt",
                                                         exception_item_not_stored)
