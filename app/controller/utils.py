"""
utils.py
"""
import csv
import sys
import socket
import json
import re
import logging
import hashlib
import requests
import ssdeep
import pefile
import configuration_file as cfg
from werkzeug.utils import secure_filename

def break_csv(lines):
    """
    empty
    """
    for line in lines:
        if line.startswith('#'):
            lines.remove(line)
    reader = csv.reader(lines, quotechar='"',
                        delimiter=',',
                        quoting=csv.QUOTE_ALL,
                        skipinitialspace=True)
    next(reader)
    return reader

def init_connection_urlhaus():
    """
    Initialisation, connection to Url Haus
    Params:
    Returns:
    """
    try:
        logging.info('Fetching latest URLhaus list...')
        request = requests.get(cfg.urlhaus["link"])
        if request.status_code == 200:
            logging.info('Processing URLhaus list...')
            return request
        logging.error('Problem connecting to URLhaus. Status code: %i', request.status_code)

    except requests.exceptions.ConnectionError as error_connection:
        logging.warning('Problem connecting to URLhaus. Error: %i', error_connection)

    except Exception as exception:
        logging.warning('Problem connecting to URLhaus. Aborting task.')
        logging.exception(sys.exc_info())
        logging.exception(type(exception))
        logging.exception(exception.args)
        logging.exception(exception)

    return []

def clean_url(url):
    """
    Remove extraneous characters from URL.
    Params:
    - url: (type: string) URL to clean.
    Returns:
    - url: (type: string) clean URL.
    """
    if url is None:
        return None
    if '??' in url:
        url = url.split('??')[0]
    if url.endswith('?'):
        url = url[:-1]
    if '`' in url:
        url = url.replace('`', '')
    return url

def get_name_file_from_url(url):
    """
    Get name file from url
    Params:
    - url: (type: string).
    Returns:
    - name: (type: string).
    """

    last_slash = url.rfind('/')
    return url[last_slash+1:]

def save_infos_from_csv(item):
    """
    SAVE INFOS FROM CSV
    Params:
    - item: (type: string) URL.
    Returns:
    - id_malware, date_added, url_malware, url_status, threat, tags, urlhaus_link, reporter.
    """
    id_malware = item[0]
    date_added = item[1]
    url_malware = clean_url(item[2])
    if item[3] == "online":
        url_status = True
    else:
        url_status = False
    threat = item[4]
    tags = item[5]
    urlhaus_link = item[6]
    reporter = item[7]
    return id_malware, date_added, url_malware, url_status, threat, tags, urlhaus_link, reporter

def save_vt_report(vt_report, id_malware):
    with open(str(id_malware) + ".vt", "w+") as outfile:
        json.dump(vt_report, outfile)
        outfile.close()

def get_ip_geo_from_url(input):
    """Mofication Parser url et recuperer la partie essentiel pour analyser apres"""
    compile_rule1 = re.compile('^(?:http:\/\/|www\.|https:\/\/)([^\/]+)')
    match1 = re.match(compile_rule1, input)
    """Verifier cela est une addresse IP ou pas"""
    compile_rule = re.compile(r'(?<![\.\d])(?:\d{1,3}\.){3}\d{1,3}(?![\.\d])')
    match = re.match(compile_rule, match1.group(1))
    """Si cela est une addresse IP"""
    if match:
        ip = match.group()
    else:
        try:
            ip = socket.getaddrinfo(match1.group(1), 'http')[0][4][0]
        except:
            ip = "0.0.0.0"
    """A l aide du site ipstack, lire les donnÃ©es de cette addresse"""
    url = 'http://api.ipstack.com/' + ip + '?access_key=' + cfg.ipstack['apikey']
    try:
        a = requests.get(url)
        data = a.json()
    except:
        return "none", "none", "none", "none", "none", "none", "none", "none", "none", 0.0, 0.0, "none"
    country_name = data.get('country_name')
    ip = data.get('ip')
    continent_code = data.get('continent_code')
    continent_name = data.get('continent_name')
    country_code = data.get('country_code')
    region_code = data.get('region_code')
    region_name = data.get('region_name')
    city = data.get('city')
    zip = data.get('zip')
    latitude = data.get('latitude')
    longitude = data.get('longitude')
    full_report = data
    return ip, country_name, country_code, continent_name, continent_code, region_name, region_code, city, zip, latitude, longitude, full_report

def get_md5(fname):
    """
    Get malwate MD5
    Params:
    -fname
    Returns:
    - rslt
    """

    hash_md5 = hashlib.md5()
    with open(cfg.malware["malware_path"] + secure_filename(fname), 'rb') as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    rslt = hash_md5.hexdigest()
    return rslt

def get_sha256(fname):
    """
    Get malware sha256
    Params:
    -fname
    Returns:
    - rslt
    """

    hash_sha256 = hashlib.sha256()
    with open(cfg.malware["malware_path"]  + secure_filename(fname), 'rb') as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_sha256.update(chunk)
    rslt = hash_sha256.hexdigest()
    return rslt

def get_sha1(fname):
    """
    Get malware sha1
    Params:
    -fname
    Returns:
    - rslt
    """

    hash_sha1 = hashlib.sha1()
    with open(cfg.malware["malware_path"]  + secure_filename(fname), 'rb') as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_sha1.update(chunk)
    rslt = hash_sha1.hexdigest()
    return rslt

def get_ssdeep(fname):
    """
    Get malware ssdeep
    Params:
    -fname
    Returns:
    - rslt
    """

    hash_ssdeep = ssdeep.Hash()
    with open(cfg.malware["malware_path"]  + secure_filename(fname), 'rb') as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_ssdeep.update(chunk)
    rslt = hash_ssdeep.digest()
    return rslt

def get_imphash(fname):
    """
    If the malwre is an exec get the impash
    Params:
    -fname, db
    Returns:
    - imps
    """
    try:
        imps = []
        p = pefile.PE(cfg.malware["malware_path"]  + secure_filename(fname))
        imphash = p.get_imphash()
        imps.append(imphash)
        return str(imps)
    except:
        return None

def is_exe(tags):
    """
    If the malwre is an exec
    Params:
    -tags (source csv urlhaus)
    Returns:
    - boolean
    """
    if "exe" in tags:
        return True
    return False
